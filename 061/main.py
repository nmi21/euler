"""
Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are
generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P4,n=n2	 	        1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the
last number with the first).
Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a
different number in the set.
This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square,
pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

---
Method:
- make a function for each of the formulae
- we know that the numbers are going to be 4 digits long, and so build sets that include all numbers of 4 digits
- Note: we have repeat numbers in between the groups and so we have to be careful about how we measure the end of our
search function
-
- use recursion to find the set of numbers that could work
"""
from itertools import count
import copy


def P3(n):
    return int(n * (n + 1) / 2)


def P4(n):
    return n ** 2


def P5(n):
    return int(n * (3 * n - 1) / 2)


def P6(n):
    return n * (2 * n - 1)


def P7(n):
    return int(n * (5 * n - 3) / 2)


def P8(n):
    return n * (3 * n - 2)


def is_cyclic(n, m):
    if n % 100 == m // 100:
        return True
    return False


def recursive_solve(state, lists):
    if set(state["traversed_lists"]) == set(list(range(len(lists)))) and is_cyclic(state["tree"][-1], state["tree"][0]):
        return state["tree"]
    for ind, num_list in enumerate(lists):
        if ind not in state["traversed_lists"]:
            for ele in num_list:
                if not state["tree"] or is_cyclic(state["tree"][-1], ele):
                    new_state = copy.deepcopy(state)
                    new_state["traversed_lists"].append(ind)
                    new_state["tree"].append(ele)
                    path = recursive_solve(new_state, lists)
                    if path:
                        return path
    return None


def solve(lists):
    state = {
        "traversed_lists": [],
        "tree": []
    }

    return recursive_solve(state, lists)


func_sets = {
    3: P3,
    4: P4,
    5: P5,
    6: P6,
    7: P7,
    8: P8
}
num_sets = {
    3: [],
    4: [],
    5: [],
    6: [],
    7: [],
    8: []
}

for p in range(3, 8 + 1):
    for n in count(1):
        num = func_sets[p](n)
        if num < 1000:
            continue
        if num > 9999:
            break
        num_sets[p].append(num)

# recreate the results from the example, using only the tri, square, and pent numbers
num_sets = {key: val for key, val in num_sets.items() if key in list(range(3, 9))}
num_list = [num_sets[i] for i in range(3, 9)]

# print(num_list)
# print(num_sets)


res = solve(num_list)
# print(res)

ans = sum(res)
print(ans)

