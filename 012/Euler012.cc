/*
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be
1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?


----
Method:
- we know a handful of things:
    - a triangle number Tn -- 1 + 2 + 3 + ... + n -- is the same as a Gaussian summation Σn
    - Σn = 1 + 2 + 3 + ... + n = n(n+1)/2
    - therefore, we can easily calculate the value for any Tn by using n(n+1)/2
- note the following:
    - n(n+1)/2 == (2^-1) * n * (n+1)
    - one of n or n+1 must be even, and the other must be odd
    - thus, only one of n or n+1 can have a factor of 2
    - thus, we will always be able to account for the 2^-1 factor
    - a number can be prime factorized in the following way:
        - x = p1^a * p2^b * ... * px^i
    - and then the total number of factors can be determined by the following formula:
        - Π(i-1) = (a-1) * (b-1) * ... * (i-1)
- therefore, we can solve in the following way:
    - prime factorize n and n+1
    - determine if factors for n or n+1 have 2 in them and then subtract 1 from the factorization that does
    - calculate total factors for Tn
    - if total factors > 500, exit and report n; else loop through to next value of n, noting that you can shift n+1
    data to become n data
*/

#include <iostream>
#include <vector>
#include <math.h>

int triangle_number(const int& n) {
    // Generates a triangular number T(n)

    return n * (n + 1) / 2;
}

bool is_prime(const int& n) {
    // checks if a number, n, is prime
    
    if (n < 2) {
        return false;
    }
    
    if (n == 2) {
        return true;
    }
    
    if (n % 2 == 0) {
        return false;
    }
    
    int sq_n = int(sqrt(n));
    for (int i = 3; i < sq_n; i += 2) {
        if (n % i == 0) {
            return false;
        }
    }

    return true;
}

void add_prime(std::vector<int> & prime_vector) {
    // takes in a vector and adds on the next prime to it
    int n = prime_vector[prime_vector.size() - 1] + 2;

    while (!is_prime(n)) {
        n += 2;
    }

    prime_vector.push_back(n);
}

std::vector<int> prime_factors(const int & n, std::vector<int> & prime_vector) {
    // Returns a vector of all prime factors of n in a way that the index is linked to the prime index from the prime vector

    
    while (prime_vector[prime_vector.size() - 1] < n) {
        add_prime(prime_vector);
    }

    int m = n;
    std::vector<int> prime_factors;
    for (auto prime : prime_vector) {
        int count = 0;
        while (m % prime == 0) {
            count += 1;
            m = m / prime;
        }
        prime_factors.push_back(count);
    }

    return prime_factors;
}

int num_factors(const std::vector<int> & n_0_factors, const std::vector<int> & n_1_factors) {
    std::vector<int> n_0_f = n_0_factors;
    std::vector<int> n_1_f = n_1_factors;

    if (n_0_f[0] > 0) {
        n_0_f[0] -= 1;
    } else if (n_1_f[0] > 0) {
        n_1_f[0] -= 1;
    }

    int prod = 1;
    for (auto factor : n_0_f) {
        prod *= (factor + 1);
    }
    for (auto factor : n_1_f) {
        prod *= (factor + 1);
    }

    return prod;
}

int main() {

    int limit = 500;

    std::vector<int> primes {2, 3};

    int n_0 = 1;
    int n_1 = n_0 + 1;
    std::vector<int> n_0_factors = prime_factors(n_0, primes);
    std::vector<int> n_1_factors = prime_factors(n_1, primes);

    while (num_factors(n_0_factors, n_1_factors) < limit) {
        n_0 = n_1;
        n_1 += 1;
        n_0_factors = n_1_factors;
        n_1_factors = prime_factors(n_1, primes);
    }

    std::cout << "ans == " << triangle_number(n_0) << std::endl;

    return 0;
}